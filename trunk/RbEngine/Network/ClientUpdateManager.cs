using System;
using System.Collections;

namespace RbEngine.Network
{
	/*
	 * TcpClientConnectionListener listens out for client connections. If it finds one, it creates
	 * a connection, and a ClientUpdateManager based on that connection. The manager updates on
	 * a fixed time-step. Entity client update components subscribe to the manager, which requests
	 * update messages, which it collates into a single large packet that is sent over the connection
	 */

	/// <summary>
	/// Listens for client update messages over the client-server connection
	/// </summary>
	public class ClientUpdateManager : Scene.ISceneObject
	{
		#region	Updaters

		/// <summary>
		/// Adds a client updater to the manager
		/// </summary>
		public void AddUpdater( IClientUpdater updater )
		{
			m_Updaters.Add( updater );
		}

		/// <summary>
		/// Removes an updater from the manager
		/// </summary>
		public void RemoveUpdater( IClientUpdater updater )
		{
			m_Updaters.Remove( updater );
		}

		#endregion

		#region	Private stuff

		private ArrayList	m_Connections	= new ArrayList( );
		private ArrayList	m_Updaters		= new ArrayList( );

		/// <summary>
		/// Adds a new connection
		/// </summary>
		private void OnNewClientConnection( IConnection connection )
		{
			m_Connections.Add( connection );
		}

		/// <summary>
		/// Network update tick
		/// </summary>
		private void OnTick( Scene.Clock clock )
		{
			//	Run through all the updaters
			foreach ( IClientUpdater curUpdater in m_Updaters )
			{
				Components.Message[] updateMessages = curUpdater.CreateUpdateMessages( );
				if ( ( updateMessages != null ) && ( updateMessages.Length > 0 ) )
				{
					//	Concrete update model:
					//	- Server side:
					//		- Updater local update:
					//			- Each updater stores states up to last client ACK
					//		- Updater client update:
					//			- For each client
					//				- Each updater calculates the delta from the current state to the state at the time of the last client ACK
					//				- Each updater returns information to the update manager (in the form of a message), containing the updater state deltas
					//				- The update manager batches those messages and sends them to the current client, with an attached sequence number denoting
					//				  the current tick count
					//
					//	- Client side:
					//		- Listener server update:
					//			- If a message is received by the server listener
					//				- If its sequence number is less than the last received batch message sequence number, the message is ignored (handles unreliable protocol)
					//				- Otherwise, the updater messages are unbatched, and directed to the appropriate locations
					//					- Also, an acknowledgment is sent to the server, storing the batch message sequence number (the acknowledgement must be reliable?)
					//		- Server updater:
					//			- 

					//	Run through all the messages generated by the updater
					for ( int messageIndex = 0; messageIndex < updateMessages.Length; ++messageIndex )
					{
						//	Run through all the connections
						foreach ( IConnection curConnection in m_Connections )
						{
							//	Deliver the message to the client
							curConnection.DeliverMessage( updateMessages[ messageIndex ] );
						}
					}
				}
			}
		}

		#endregion

		#region ISceneObject Members

		/// <summary>
		///	Called when this object is added to a scene
		/// </summary>
		public void AddedToScene( Scene.SceneDb db )
		{
			//	Get the Connections object from the scene systems
			Connections connections = ( Connections )db.GetSystem( typeof( Connections ) );
			if ( connections == null )
			{
				throw new ApplicationException( "ClientUpdateManager requires that a Connections object be present in the scene systems" );
			}

			//	Subscribe to the new client connection event
            connections.NewClientConnection += new NewClientConnectionDelegate( OnNewClientConnection );
		}

		/// <summary>
		///	Called when this object is removed from a scene
		/// </summary>
		public void RemovedFromScene( Scene.SceneDb db )
		{
		}

		#endregion
	}
}

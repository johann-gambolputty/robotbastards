using System;
using Poc1.Fast.Terrain;
using Poc1.Universe.Interfaces;
using Poc1.Universe.Interfaces.Planets.Models;
using Poc1.Universe.Interfaces.Planets.Renderers.Patches;
using Poc1.Universe.Interfaces.Planets.Spherical.Models;
using Poc1.Universe.Interfaces.Rendering;
using Rb.Rendering.Interfaces.Objects;
using ITerrainPatch=Poc1.Universe.Interfaces.Planets.Renderers.Patches.ITerrainPatch;
using Poc1.Universe.Interfaces.Planets.Spherical;

namespace Poc1.Universe.Planets.Spherical.Models
{
	/// <summary>
	/// Terrain model implementation for spherical planets
	/// </summary>
	public class SpherePlanetProcTerrainModel : ISpherePlanetTerrainModel, IPlanetProcTerrainModel, ITerrainPatchGenerator
	{
		/// <summary>
		/// Sets up the model to generate terrain for a particular planet instance
		/// </summary>
		public SpherePlanetProcTerrainModel( ISpherePlanet planet )
		{
			m_Planet = planet;
		}

		#region IPlanetTerrainModel Members


		public ITexture2d TerrainTypesTexture
		{
			get
			{
				throw new Exception( "The method or operation is not implemented." );
			}
			set
			{
				throw new Exception( "The method or operation is not implemented." );
			}
		}

		public ITexture2d TerrainPackTexture
		{
			get
			{
				throw new Exception( "The method or operation is not implemented." );
			}
			set
			{
				throw new Exception( "The method or operation is not implemented." );
			}
		}

		#endregion

		#region ITerrainPatchGenerator Members

		/// <summary>
		/// Generates vertices for a patch
		/// </summary>
		/// <param name="patch">Patch</param>
		/// <param name="res">Patch resolution</param>
		/// <param name="uvRes">UV coordinate resolution over entire patch</param>
		/// <param name="firstVertex">Patch vertices</param>
		public unsafe void GenerateTerrainPatchVertices( ITerrainPatch patch, int res, float uvRes, TerrainVertex* firstVertex )
		{
			m_Gen.GenerateVertices( patch.LocalOrigin, patch.LocalUStep, patch.LocalVStep, res, res, uvRes, firstVertex );
		}

		/// <summary>
		/// Generates vertices for a patch. Calculates maximum error between this patch and next higher detail patch
		/// </summary>
		/// <param name="patch">Patch</param>
		/// <param name="res">Patch resolution</param>
		/// <param name="uvRes">UV coordinate resolution over entire patch</param>
		/// <param name="firstVertex">Patch vertices</param>
		/// <param name="error">Maximum error value between this patch and higher level patch</param>
		public unsafe void GenerateTerrainPatchVertices( ITerrainPatch patch, int res, float uvRes, TerrainVertex* firstVertex, out float error )
		{
			m_Gen.GenerateVertices( patch.LocalOrigin, patch.LocalUStep, patch.LocalVStep, res, res, uvRes, firstVertex, out error );
		}

		#endregion

		#region IPlanetProcTerrainModel Members

		/// <summary>
		/// Sets up the terrain functions
		/// </summary>
		/// <param name="maxHeight">Maximum height of the terrain</param>
		/// <param name="heightFunction">The terrain height function</param>
		/// <param name="groundFunction">The terrain ground offset function</param>
		public void SetupTerrain( float maxHeight, TerrainFunction heightFunction, TerrainFunction groundFunction )
		{
			float radius = m_Planet.Radius.ToRenderUnits;
			float height = m_Planet.TerrainModel.MaximumHeight.ToRenderUnits;

			// NOTE: AP: Patch scale is irrelevant, because vertices are projected onto the function sphere anyway
			m_Gen = new TerrainGenerator( TerrainGeometry.Sphere, heightFunction, groundFunction );
			m_Gen.Setup( 1024, radius, radius + height );
			m_Gen.SetSmallestStepSize( MinimumStepSize, MinimumStepSize );

			if ( ModelChanged != null )
			{
				ModelChanged( this, null );
			}
		}

		#endregion

		#region IPlanetTerrainModel Members

		/// <summary>
		/// Event, invoked when the terrain model changes
		/// </summary>
		public event EventHandler ModelChanged;

		/// <summary>
		/// Gets/sets the maximum height of terrain generated by this model
		/// </summary>
		/// <remarks>
		/// On set, the ModelChanged event is invoked.
		/// </remarks>
		public Units.Metres MaximumHeight
		{
			get { return m_MaximumHeight; }
			set
			{
				m_MaximumHeight = value;
				if ( ModelChanged != null )
				{
					ModelChanged( this, null );
				}
			}
		}

		#endregion

		#region Private Members

		private TerrainGenerator m_Gen;
		private ISpherePlanet m_Planet;
		private Units.Metres m_MaximumHeight = new Units.Metres( 3000 );

		/// <summary>
		/// Terrain generator minimum step size. 4 samples are taken from the terrain geometry model, using
		/// this step size, around a central sample, to calculate the terrain normal
		/// </summary>
		private const float MinimumStepSize = 0.01f;

		#endregion

	}
}

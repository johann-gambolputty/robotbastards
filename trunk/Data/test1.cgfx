
struct SpecularTestOutput
{
	float4	m_Position : POSITION;
	float4	m_Colour : COLOR0;
};

struct SpecularTestInput
{
	float4	m_Position : POSITION;
	float4	m_Normal : NORMAL;
};

struct SpotLightArray
{
	float4		m_Positions[ 4 ];
	float4		m_Directions[ 4 ];
	float		m_ArcRadians[ 4 ];
	int			m_NumLights;
};

SpotLightArray	SpotLights;

float4x4	ModelViewProjectionMatrix;
float4x4	ModelViewMatrix;
float4x4	InverseTransposeModelViewMatrix;
float4		LightPos = float4( 12, 40, 30, 0 );
float3		EyePosition;


SpecularTestOutput PlainVanilla( SpecularTestInput input )
{
	SpecularTestOutput output;

	output.m_Position		= mul( ModelViewProjectionMatrix, input.m_Position );

	float3 normal			= normalize( mul( InverseTransposeModelViewMatrix, input.m_Normal ).xyz );
	float dp				= dot( normal, float3( 0, 0, 1 ) ); //normalize( mul( ModelViewMatrix, LightPos ).xyz ) );
	output.m_Colour.rgba	= float4( dp, 0, 0, 1 );

	return output;
}

SpecularTestOutput SpecularTest( SpecularTestInput input )
{
	SpecularTestOutput output;

	output.m_Position	= mul( ModelViewProjectionMatrix, input.m_Position );

	float3 normal		= normalize( mul( InverseTransposeModelViewMatrix, input.m_Normal ).xyz );
	float3 eyeVec		= normalize( mul( ModelViewMatrix, float4( EyePosition, 0 ) ).xyz );
//	float3 lightVec		= normalize( mul( ModelViewMatrix, LightPos ).xyz );
	float3 lightVec		= normalize( mul( ModelViewMatrix, SpotLights.m_Positions[ 0 ] ).xyz );
	float3 halfVec		= normalize( eyeVec + lightVec );

	float diffuse		= dot( normal, lightVec );
	float specular		= dot( normal, halfVec );

	float4 lighting		= lit( diffuse, specular, 64 );

	output.m_Colour.rgb = lighting.y * float3( 0, 0, 1 ) + lighting.z * float3( 1, 1, 1 );
	output.m_Colour.a	= 1;

	return output;
}


technique SpecularTestTechnique
{
	pass
	{
		ShadeModel				= Smooth;
		FrontFace				= CW;
		DepthFunc				= LEqual;
		DepthTestEnable			= true;
		CullFaceEnable			= true;
		PolygonMode				= int2( Front, Fill );
		VertexProgram			= compile arbvp1 SpecularTest( );
	}
	pass
	{
		FrontFace				= CW;
		DepthTestEnable			= true;
		CullFaceEnable			= true;
		PolygonMode				= int2( Front, Line );
		PolygonOffsetLineEnable	= true;
		PolygonOffset			= float2( -0.5, -0.5 );
		LightingEnable			= true;	//	TODO: This is a bodge to get the wireframe rendered black
	}
}


struct WireIn
{
	float4	pos : POSITION;
	float4	normal : NORMAL;
};

struct WireOut
{
	float4 pos : POSITION;
	float4 colour : COLOR0;
};

WireOut WireframeVertexShader( WireIn input )
{
	WireOut output;

	output.pos		= mul( ModelViewProjectionMatrix, input.pos );
	output.colour	= float4( 0, 0, 0, 1 );

	return output;
}

technique Wireframe
{
	pass
	{
		ShadeModel		= Smooth;
		FrontFace		= CW;
		DepthFunc		= LEqual;
		CullFaceEnable	= false;
		DepthTestEnable	= false;
		PolygonMode		= int2( FrontAndBack, Line );
		VertexProgram	= compile arbvp1 WireframeVertexShader( );
	}
}

technique BlobTechnique
{
	pass
	{
		ShadeModel		= Smooth;
		FrontFace		= CW;
		DepthFunc		= LEqual;
		DepthTestEnable	= true;
		PolygonMode		= int2( Front, Fill );
		VertexProgram	= compile arbvp1 PlainVanilla( );
	}
}
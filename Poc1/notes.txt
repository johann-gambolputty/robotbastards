- Terrain types
	- Dependent on elevation, slope, latitude
	- Use 2d noise (x,z) to offset type calculation
	- Each type gets their own contribution value, weighted by (e,s,l) weights
		- E(p) == elevation
		- S(p) == slope
		- L(p) == latitude
		- Te(e) == Distribution of terrain type at elevation
		- Ts(e) == Distribution of terrain type at slope
		- Tl(e) == Distribution of terrain type at latitude
		- Tc = Te(E(p)).Ts(S(p)).Tl(L(p)).Noise(p)
		- Partly finished - implemented as TerrainDistribution class

		- Works OK, but would be better if L(p) is removed, and instead add E(p) and S(p)
		for different latitude bands.

- Patch splat texturing without pixel shader U/V wrapping:
	- Patch initial visibility:
		- Determine all terrain types affecting the patch
		- There should be a maximum of N=4, possibly 6, per patch
		- If there's more than N terrain types, just use one of the existing terrain types
		- Munge terrain type byte IDs into an int32
		- Store this value in the patch (TerrainPackID)
		- If terrain pack ID is a 64 bit value, can add quantised distance to camera to last 16-32 bits, for free z-sorting
	- Sort visible patches by TerrainPackID
	- For each visible patch in sorted list:
		- If TerrainPackID has changed from previous visible patch:
			- Load up 

- This same scheme can be used to define terrain packs, with pixel shader u/v wrapping:
	- 
	- 

- Links:
	- Rendering WPF into bitmaps (part of the solution...):
		- http://www.west-wind.com/WebLog/posts/150676.aspx

	- Notes on procedural terrain:
		- http://www.gamedev.net/community/forums/mod/journal/journal.asp?jn=263350&cmonth=8&cyear=2007

	- Not really relevent, but data for the stanford bunny is here:
		- http://www.codesampler.com/oglsrc/oglsrc_6.htm

	- Megaparticle systems (for cloud rendering?):
		- http://www.2ld.de/gdc2004/MegaParticlesPaper.pdf

	- Godray discussion:
		- http://www.ogre3d.org/phpBB2/viewtopic.php?p=283158&sid=ce193664e1d3d7c4af509e6f4e2718c6

	- Bezier patch terrain:
		- http://www.gamasutra.com/view/feature/3004/dynamic_level_of_detail_terrain_.php?print=1

	- Splatting:
		- http://www.cbloom.com/3d/techdocs/splatting.txt

	- Terrain LOD:
		- http://number-none.com/product/Unified%20Rendering%20LOD,%20Part%201/index.html

	- Nice terrain textures:
		- http://www.gamedev.net/community/forums/topic.asp?topic_id=263350

	- SSE problems with noise generation:
		- http://www.gamedev.net/community/forums/topic.asp?topic_id=469446
	
	- Interesting thumbnail provider code:
		- http://www.gamedev.net/community/forums/mod/journal/journal.asp?jn=273102

	- Normal mapping in HLSL
		- http://dotnet.org.za/pieterg/archive/2005/07/29/40407.aspx

	- Chunked LOD
		- http://www.tulrich.com/geekstuff/sig-notes.pdf

	- Vertex attrib pointers (rather than specific client arrays)
		- http://www.opengl.org/sdk/docs/man/xhtml/glVertexAttribPointer.xml

	- TerrAnim8tor
		- (Tan8 UV mapping for terrain textures)
		- http://www.biederman.net/leslie/tutorials/Terranim8or/terrain/terrain3.htm

- Profiling code pretty much done
	- Add bits to controls
	- Save profile logs
		- Add .exe profile viewer that can be associated with profile logs
	- Add named events?
	- Add axis to graphs
	- Add zoom in/out buttons
	- Make data page an expando control rather than a tab page
	- Add pause button
	- Add labelling to graph lines on mouse hover
	- Add sample rate up/down spinner

- stuff
	- Biome
		- http://en.wikipedia.org/wiki/Biome
		- A biome is a climatically and geographically defined area of ecologically similar communities of plants,
		  animals, and soil organisms, often referred to as ecosystems.

	- Earth
		- Equatorial radius: 6,378.1km
		- Polar radius: 6,371.0km
		- Rotational speed at equator: 465.11 m/s

	- Moon
		- Equatorial radius: 1,737.10 km
		- Rotational speed at equator: 4.627 m/s

- TODO
	- Terrain
		- H: Vertex indexing error when ReduceDetail() is called on a patch with the new mt terrain builder
		- M: Geomorphing
		- M: Add noise to terrain type texture
		- M: Cull quad tree nodes (frustum + horizon culling for spherical planets)
		- L: Pop slope/altitude determination in fragment shader (it's done at a vertex level - can work it out implicitly in frag shader)
		- L: Add x/z displacement decorator class
		- ?: Now that patches are independent of one another (skirts), can use UniPoint as patch centre (unique transform per patch, though)
	- Environment
		- L: Volumetric clouds
		- L: Vegetation
		- L: Animal life
	- Planets
		- H: Large radius planets (>1000km)
			- H: Fix larger radius planets (lots of z-fighting, no terrain detail)		- H: Terrain function sphere needs radius dependent on radius of planet (or moons = extra spiky)
			- H: Cloud level dependent on planet radius also
		- H: Atmospheric shaders
		- M: Add planetary rings
		- M: Add moons back in
		- M: Add sun
		- M: Add light scattering post-process (god-rays)
		- L: Crater terrain function for moons
		- L: Crater terrain types for moons
		- L: Gas-giant shaders
		- L: Non-spherical planets
			- L: Ring-worlds
			- L: Hollow spheres
		- ?: Restore planet cube map (necessary?)
	- Water
		- H: Sea
		- L: Lakes
		- L: Rivers
	- Cities
		- L: Buildings
		- L: Roads
		- L: Traffic
		- L: Pedestrians
	- Solar system
		- M: Proper procedural star-spheres
	- Assets
		- L: Asset build should have a UI (progress bar, output text)
		- L: Add bigfile support
		- L: Game assets aware of changes to design objects
			- Perhaps with a service that monitors the design folders?
			- Needs following commands:
				- "Rebuild All"
				- "Build All" (only updates game assets with an earlier timestamp that design assets)
				- "ReBuild" (builds a single named asset)
				- "Build" (builds a single asset)
			- In-game UI
			- Build/Rebuild menu items
	- UI
		- M: Try getting WPF to work
		- M: Profile UI needs fixed scales (adaptive scales is stupid and misleading)
		- L: Ship HUD
	- Ships
		- H: Basic ship graphics
		- H: Get basic ship dynamics working
		- M: Connectors
		- M: Shaders
		- M: Simple ship combat
		- L: Internal ship modelling

	- Networking
		- H: Extend RUNT
@echo ON
echo Building rendering implementations...
vsvars32
msbuild "$(SolutionDir)..\..\source\rb.rendering.implementations\rb.rendering.implementations.csproj" /t:Build /p:Configuration=$(ConfigurationName) /p:CopyTo="$(TargetDir)"

	- Graphics Misc.
		- H: Shadows
		- M: Particle systems
		- M: Move rendering assemblies to separate sub-directories (e.g. bin\OpenGL), rather than making them
		  explicit references.
		- M: Make the effect assembly load on-demand (i.e. when the effect manager is referenced)
		- M: Fullscreen mode
		- L: Multimonitor support

	- Profiling
		- H: Patch rendering is slow

	- Misc.
		- Remove fast noise test (move to console app. project)

- DONE
	- Assets: Design to Game builds
	- Terrain: Multi-threading to queue up patch creation
	- Terrain: Keep terrain patches after they are popped
	- Terrain: Clamp slope 
	- Environment: Simple cloud cover	
	- Terrain: Local terrain function sampling to determine high-quality normals even for coarse patches
	- Misc: Refactoring: Split out fast terrain code into Poc1.Fast.Terrain (keep Poc1.Fast for shared stuff like aligned allocations)

		

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using Rb.Core.Maths;
using Rb.Rendering.Interfaces.Objects;
using Tao.OpenGl;
using Rectangle=System.Drawing.Rectangle;

namespace Rb.Rendering.OpenGl
{
	/// <summary>
	/// Static helper class for building 2d textures
	/// </summary>
	public static class OpenGlTexture2dBuilder
	{
		#region TextureInfo Struct

		/// <summary>
		/// Information about textures generated by this class
		/// </summary>
		public struct TextureInfo
		{
			/// <summary>
			/// GL texture internal format
			/// </summary>
			public int GlInternalFormat;

			/// <summary>
			/// GL texel format
			/// </summary>
			public int GlFormat;

			/// <summary>
			/// GL texel type
			/// </summary>
			public int GlType;

			/// <summary>
			/// Texture format
			/// </summary>
			public TextureFormat TextureFormat;

			/// <summary>
			/// Setup constructor
			/// </summary>
			public TextureInfo( int glInternalFormat, int glFormat, int glType, TextureFormat textureFormat )
			{
				GlInternalFormat = glInternalFormat;
				GlFormat = glFormat;
				GlType = glType;
				TextureFormat = textureFormat;
			}
		}


		#endregion

		#region Texture parameters

		/// <summary>
		/// Gets an integer texture parameter
		/// </summary>
		public static int GetTextureLevelParameterInt32( int target, int level, int parameter )
		{
			int[] param = new int[ 1 ];
			Gl.glGetTexLevelParameteriv( target, level, parameter, param );
			return param[ 0 ];
		}

		#endregion

		/// <summary>
		/// Creates a bitmap from the currently bound texture
		/// </summary>
		public unsafe static Bitmap CreateBitmapFromTexture( int target, int level, TextureFormat format )
		{
			int width = GetTextureLevelParameterInt32( target, level, Gl.GL_TEXTURE_WIDTH );
			int height = GetTextureLevelParameterInt32( target, level, Gl.GL_TEXTURE_HEIGHT );

			GraphicsLog.Verbose( "Creating bitmap from level {0} in {1}x{2} {3} texture", level, width, height, format );

			if ( ( format == TextureFormat.Depth16 ) || ( format == TextureFormat.Depth24 ) || ( format == TextureFormat.Depth32 ) )
			{
				return CreateBitmapFromDepthTexture( target, level, width, height );
			}

			//	Handle colour textures

			//	Get texture memory
			int bytesPerPixel = TextureFormatInfo.GetSizeInBytes( format );
			TextureInfo info = CheckTextureFormat( format );
			byte[] textureMemory = new byte[ width * height * bytesPerPixel ];
			Gl.glGetTexImage( Gl.GL_TEXTURE_2D, level, info.GlFormat, info.GlType, textureMemory );

			//	TODO: Same problem as above...

			//	Create a Bitmap object from image memory
			fixed ( byte* textureMemoryPtr = textureMemory )
			{
				//	TODO: Add per-case check of Format - in cases with no mapping (see TextureFormatToPixelFormat()), do a manual conversion
				return new Bitmap( width, height, width * bytesPerPixel, TextureFormatInfo.ToPixelFormat( format ), ( IntPtr )textureMemoryPtr );
			}
		}

		/// <summary>
		/// Creates texture data from the currently bound texture
		/// </summary>
		public static Texture2dData[] CreateTextureDataFromTexture( int target, TextureFormat format )
		{
			int width;
			int height;
			int level = 0;
			List< Texture2dData > textureDataList = new List< Texture2dData >( );
			do
			{
				width = GetTextureLevelParameterInt32( target, level, Gl.GL_TEXTURE_WIDTH );
				height = GetTextureLevelParameterInt32( target, level, Gl.GL_TEXTURE_HEIGHT );

				GraphicsLog.Verbose( "Creating texture data from level {0} ({1}x{2}) {3} texture", level, width, height, format );

				//	Get texture memory
				int bytesPerPixel = TextureFormatInfo.GetSizeInBytes( format );
				TextureInfo info = CheckTextureFormat( format );
				byte[] textureMemory = new byte[ width * height * bytesPerPixel ];
				Gl.glGetTexImage( Gl.GL_TEXTURE_2D, level, info.GlFormat, info.GlType, textureMemory );

				Texture2dData textureData = new Texture2dData( );
				textureData.Create( width, height, format, textureMemory );
				textureDataList.Add( textureData );

				++level;

			} while ( ( width > 1 ) && ( height > 1 ) );


			return textureDataList.ToArray( );
		}

		/// <summary>
		/// Creates a texture image from a bitmap
		/// </summary>
		public static TextureInfo CreateTextureImageFromBitmap( int target, Bitmap bmp, bool generateMipMaps )
		{
			TextureInfo info = CheckBitmapFormat( ref bmp );

			//	Lock the bitmap, and create the texture
			BitmapData bmpData = LockEntireBitmap( bmp );
			if ( generateMipMaps )
			{
				Glu.gluBuild2DMipmaps( target, info.GlInternalFormat, bmpData.Width, bmpData.Height, info.GlFormat, info.GlType, bmpData.Scan0 );
			}
			else
			{
				Gl.glTexImage2D( target, 0, info.GlInternalFormat, bmpData.Width, bmpData.Height, 0, info.GlFormat, info.GlType, bmpData.Scan0 );
			}
			bmp.UnlockBits( bmpData );

			return info;
		}

		/// <summary>
		/// Creates a texture image from a texture data object
		/// </summary>
		public static unsafe TextureInfo CreateTextureImageFromTextureData( int target, Texture2dData data, bool generateMipMaps )
		{
			TextureInfo info = CheckTextureFormat( data.Format );

			fixed ( void* texels = data.Bytes )
			{
				if ( generateMipMaps )
				{
					Glu.gluBuild2DMipmaps( target, info.GlInternalFormat, data.Width, data.Height, info.GlFormat, info.GlType, new IntPtr( texels ) );
				}
				else
				{
					Gl.glTexImage2D( target, 0, info.GlInternalFormat, data.Width, data.Height, 0, info.GlFormat, info.GlType, new IntPtr( texels ) );
				}
			}

			return info;
		}

		/// <summary>
		/// Creates a texture image from an array of texture data objects
		/// </summary>
		public unsafe static TextureInfo CreateTextureImageFromTextureData( int target, Texture2dData[] data )
		{
			TextureInfo info = CheckTextureFormat( data[ 0 ].Format );

			for ( int level = 0; level < data.Length; ++level )
			{
				if ( data[ level ].Format != data[ 0 ].Format )
				{
					throw new ArgumentException( string.Format( "Data in level {0} has format {1}, should be format {2}", level, data[ level ].Format, data[ 0 ].Format ) );
				}
				fixed ( void* texels = data[ level ].Bytes )
				{
					Gl.glTexImage2D( target, level, info.GlInternalFormat, data[ level ].Width, data[ level ].Height, 0, info.GlFormat, info.GlType, new IntPtr( texels ) );
				}
			}

			return info;
		}

		#region Private Members

		/// <summary>
		/// Creates a bitmap from a level in a depth texture
		/// </summary>
		private unsafe static Bitmap CreateBitmapFromDepthTexture( int target, int level, int width, int height )
		{
			//	Handle depth textures

			//	TODO: AP: Change pixel transfer?

			//	Get texture memory
			float[] textureMemory = new float[ width * height ];
			Gl.glGetTexImage( target, level, Gl.GL_DEPTH_COMPONENT, Gl.GL_FLOAT, textureMemory );

			float minDepth = float.MaxValue;
			float maxDepth = float.MinValue;
			for ( int textureIndex = 0; textureIndex < textureMemory.Length; ++textureIndex )
			{
				minDepth = Utils.Min( textureMemory[ textureIndex ], minDepth );
				maxDepth = Utils.Max( textureMemory[ textureIndex ], maxDepth );
			}

			Bitmap bmp = new Bitmap( width, height, PixelFormat.Format24bppRgb );
			BitmapData bmpData = bmp.LockBits( new Rectangle( 0, 0, width, height ), ImageLockMode.WriteOnly, PixelFormat.Format24bppRgb );

			byte* bmpMem = ( byte* )bmpData.Scan0;
			{
				int texOffset = 0;
				for ( int y = height - 1; y >= 0; --y )
				{
					byte* curBmpPixel = bmpMem + ( y * bmpData.Stride );
					for ( int x = 0; x < width; ++x )
					{
						float depth = textureMemory[ texOffset++ ];
						depth = ( depth - minDepth ) / ( maxDepth - minDepth );
						byte grey = ( byte )( depth * 255.0f );
						*( curBmpPixel++ ) = grey;
						*( curBmpPixel++ ) = grey;
						*( curBmpPixel++ ) = grey;
					}
				}
			}

			return bmp;
		}

		/// <summary>
		/// Checks the format of a Bitmap. If it's not compatible with any OpenGL formats, it's converted to a format that is
		/// </summary>
		private static TextureInfo CheckBitmapFormat( ref Bitmap bmp )
		{
			TextureInfo info;
			PixelFormat format = CheckPixelFormat( bmp.PixelFormat, out info );
			if ( format == bmp.PixelFormat )
			{
				//	No format change required in the bitmap
				return info;
			}
			GraphicsLog.Warning( "Converting bitmap to texture format " + info.TextureFormat );

			//	Unhandled format. Convert the bitmap into a more manageable form whose GL format we know
			bmp = bmp.Clone( new Rectangle( 0, 0, bmp.Width, bmp.Height ), format );
			return info;
		}
		
		/// <summary>
		/// Checks if a texture format is valid
		/// </summary>
		/// <param name="format">Format to check</param>
		/// <returns>Returns texture information</returns>
		public static TextureInfo CheckTextureFormat( TextureFormat format )
		{
			//	Handle direct mappings to GL texture image formats
			switch ( format )
			{
				case TextureFormat.Depth16			:
				{
					//	TODO: AP: Is GL_FLOAT type corect?
					return new TextureInfo( Gl.GL_DEPTH_COMPONENT16, Gl.GL_DEPTH_COMPONENT, Gl.GL_FLOAT, format );
				}
				case TextureFormat.Depth24			:
					{
						//	TODO: AP: Is GL_FLOAT type corect?
						return new TextureInfo( Gl.GL_DEPTH_COMPONENT24, Gl.GL_DEPTH_COMPONENT, Gl.GL_FLOAT, format );
				}
				case TextureFormat.Depth32			:
				{
						//	TODO: AP: Is GL_FLOAT type corect?
						return new TextureInfo( Gl.GL_DEPTH_COMPONENT32, Gl.GL_DEPTH_COMPONENT, Gl.GL_FLOAT, format );
				}
				case TextureFormat.R8G8B8			:
				{
					return new TextureInfo( Gl.GL_BGR_EXT, Gl.GL_RGB, Gl.GL_UNSIGNED_BYTE, format );
				}
				case TextureFormat.B8G8R8			:
				{
					return new TextureInfo( Gl.GL_RGB, Gl.GL_RGB, Gl.GL_UNSIGNED_BYTE, format );
				}
				case TextureFormat.R8G8B8X8			:
				{
					//	TODO: AP: Not right...
					return new TextureInfo( Gl.GL_ABGR_EXT, Gl.GL_RGB, Gl.GL_UNSIGNED_BYTE, format );
				}
				case TextureFormat.B8G8R8X8			:
				{
						//	TODO: AP: Not right...
						return new TextureInfo( Gl.GL_RGBA, Gl.GL_RGB, Gl.GL_UNSIGNED_BYTE, format );
				}
				case TextureFormat.R8G8B8A8			:
				{
					//	TODO: AP: Not right...
					return new TextureInfo( Gl.GL_ABGR_EXT, Gl.GL_RGBA, Gl.GL_UNSIGNED_BYTE, format );
				}
				case TextureFormat.A8R8G8B8			:
				{
					//	TODO: AP: Not right...
					return new TextureInfo( Gl.GL_BGRA_EXT, Gl.GL_RGBA, Gl.GL_UNSIGNED_BYTE, format );
				}
				case TextureFormat.A8B8G8R8			:
				{
					//	TODO: AP: Not right...
					return new TextureInfo( Gl.GL_RGBA, Gl.GL_RGBA, Gl.GL_UNSIGNED_BYTE, format );
				}
			}

			throw new NotSupportedException( "Unsupported texture format: " + format );
		}

		/// <summary>
		/// Checks if a pixel format is valid
		/// </summary>
		/// <param name="format">Format to check</param>
		/// <param name="info">Texture formatting information is output into this parameter</param>
		/// <returns>Returns either format, if it was directly supported by OpenGL, or a reasonable alternative</returns>
		private static PixelFormat CheckPixelFormat( PixelFormat format, out TextureInfo info )
		{
			//	Handle direct mappings to GL texture image formats
			switch ( format )
			{
				case PixelFormat.Alpha					:	break;
				case PixelFormat.Canonical				:	break;
				case PixelFormat.DontCare				:	break;
				case PixelFormat.Extended				:	break;
				case PixelFormat.Format16bppArgb1555	:	break;
				case PixelFormat.Format16bppGrayScale	:	break;
				case PixelFormat.Format16bppRgb555 		:	break;
				case PixelFormat.Format16bppRgb565 		:	break;
				case PixelFormat.Format1bppIndexed 		:	break;
				case PixelFormat.Format24bppRgb			:
				{
					info = new TextureInfo( Gl.GL_RGB, Gl.GL_BGR_EXT, Gl.GL_UNSIGNED_BYTE, TextureFormat.R8G8B8 );
					return format;
				}
				case PixelFormat.Format32bppArgb		:
				{
					info = new TextureInfo( Gl.GL_RGBA, Gl.GL_BGRA, Gl.GL_UNSIGNED_BYTE, TextureFormat.A8R8G8B8 );
					return format;
				}
				case PixelFormat.Format32bppPArgb		:	break;
				case PixelFormat.Format32bppRgb			:
				{

				//	info = new TextureInfo( Gl.GL_ABGR_EXT, Gl.GL_BGRA, Gl.GL_UNSIGNED_BYTE, TextureFormat.A8R8G8B8 );
				//	return format;
					//	glFormat			= Gl.GL_ABGR_EXT;
				//	glFormat = Gl.GL_RGBA;	//	NOTE: AP: ABGR extension not supported on dev machine! SHIT!
				//	glInternalFormat	= Gl.GL_RGBA;
				//	glType				= Gl.GL_UNSIGNED_BYTE;
					//	return format;
					info = new TextureInfo( Gl.GL_RGB, Gl.GL_BGRA, Gl.GL_UNSIGNED_BYTE, TextureFormat.A8R8G8B8 );
					return PixelFormat.Format32bppArgb;
				}
				case PixelFormat.Format48bppRgb			:	break;
				case PixelFormat.Format4bppIndexed		:	break;
				case PixelFormat.Format64bppArgb		:	break;
				case PixelFormat.Format64bppPArgb		:	break;
				case PixelFormat.Format8bppIndexed		:	break;
				case PixelFormat.Gdi					:	break;
				case PixelFormat.Indexed				:	break;
				case PixelFormat.Max					:	break;
				case PixelFormat.PAlpha					:	break;
			}

			info = new TextureInfo( Gl.GL_BGR_EXT, Gl.GL_BGR_EXT, Gl.GL_UNSIGNED_BYTE, TextureFormat.R8G8B8 );
			return PixelFormat.Format24bppRgb;
		}

		/// <summary>
		/// Locks an entire bitmap for texture creation
		/// </summary>
		private static BitmapData LockEntireBitmap( Bitmap bmp )
		{
			BitmapData bmpData = bmp.LockBits( new Rectangle( 0, 0, bmp.Width, bmp.Height ), ImageLockMode.ReadOnly, bmp.PixelFormat );

			int expectedStride = bmp.Width * ( Image.GetPixelFormatSize( bmp.PixelFormat ) / 8 );
			if ( bmpData.Stride != expectedStride )
			{
				//	Argh... we don't quite handle bitmaps with loony strides
				throw new ArgumentException( string.Format( "Unexpected stride in bitmap (was {0}, expected {1})", bmpData.Stride, expectedStride ) );
			}

			return bmpData;
		}


		/*
		 * 
		/// <summary>
		/// Checks if a texture format is valid
		/// </summary>
		/// <param name="format">Format to check</param>
		/// <param name="glInternalFormat">Output GL internal texture format</param>
		/// <param name="glFormat">Output GL texture format</param>
		/// <param name="glType">OUtput GL texel type</param>
		/// <returns>Returns either format, if it was directly supported by OpenGL, or a reasonable alternative</returns>
		public static TextureFormat CheckTextureFormat( TextureFormat format, out int glInternalFormat, out int glFormat, out int glType )
		{
			//	Handle direct mappings to GL texture image formats
			switch ( format )
			{
				case TextureFormat.Depth16			:
				{	
					glInternalFormat	= Gl.GL_DEPTH_COMPONENT16;
					glFormat			= Gl.GL_DEPTH_COMPONENT;
					glType				= Gl.GL_FLOAT;	//	TODO: Is this correct?
					return format;
				}
				case TextureFormat.Depth24			:
				{
					glInternalFormat	= Gl.GL_DEPTH_COMPONENT24;
					glFormat			= Gl.GL_DEPTH_COMPONENT;
					glType				= Gl.GL_UNSIGNED_INT;	//	TODO: Is this correct?
					return format;
				}
				case TextureFormat.Depth32			:
				{
					glInternalFormat	= Gl.GL_DEPTH_COMPONENT32;
					glFormat			= Gl.GL_DEPTH_COMPONENT;
					glType				= Gl.GL_UNSIGNED_INT;	//	TODO: Is this correct?
					return format;
				}
				case TextureFormat.R8G8B8			:
				{
					glFormat			= Gl.GL_BGR_EXT;
					glInternalFormat	= Gl.GL_RGB;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
				case TextureFormat.B8G8R8			:
				{
					glFormat			= Gl.GL_RGB;
					glInternalFormat	= Gl.GL_RGB;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
				case TextureFormat.R8G8B8X8			:
				{
					//	TODO: Not right...
					glFormat			= Gl.GL_BGR_EXT;
					glInternalFormat	= Gl.GL_RGB;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
				case TextureFormat.B8G8R8X8			:
				{
					//	TODO: Not right...
					glFormat			= Gl.GL_RGB;
					glInternalFormat	= Gl.GL_RGB;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
				case TextureFormat.R8G8B8A8			:
				{
					glFormat			= Gl.GL_ABGR_EXT;
					glInternalFormat	= Gl.GL_RGB;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
				case TextureFormat.A8R8G8B8			:
				{
					glFormat			= Gl.GL_BGRA_EXT;
					glInternalFormat	= Gl.GL_RGBA;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
				case TextureFormat.A8B8G8R8			:
				{
					glFormat			= Gl.GL_RGBA;
					glInternalFormat	= Gl.GL_RGB;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
			}

			glFormat			= Gl.GL_BGR_EXT;
			glInternalFormat	= Gl.GL_RGB;
			glType				= Gl.GL_UNSIGNED_BYTE;

			return TextureFormat.R8G8B8;
		}

		/// <summary>
		/// Checks if a pixel format is valid
		/// </summary>
		/// <param name="format">Format to check</param>
		/// <param name="glInternalFormat">Output GL internal texture format</param>
		/// <param name="glFormat">Output GL texture format</param>
		/// <param name="glType">Output GL texel type</param>
		/// <returns>Returns either format, if it was directly supported by OpenGL, or a reasonable alternative</returns>
		private static PixelFormat CheckPixelFormat( PixelFormat format, out int glInternalFormat, out int glFormat, out int glType )
		{
			//	Handle direct mappings to GL texture image formats
			switch ( format )
			{
				case PixelFormat.Alpha					:	break;
				case PixelFormat.Canonical				:	break;
				case PixelFormat.DontCare				:	break;
				case PixelFormat.Extended				:	break;
				case PixelFormat.Format16bppArgb1555	:	break;
				case PixelFormat.Format16bppGrayScale	:	break;
				case PixelFormat.Format16bppRgb555 		:	break;
				case PixelFormat.Format16bppRgb565 		:	break;
				case PixelFormat.Format1bppIndexed 		:	break;
				case PixelFormat.Format24bppRgb			:
				{
					glFormat			= Gl.GL_BGR_EXT;
					glInternalFormat	= Gl.GL_RGB;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
				case PixelFormat.Format32bppArgb		:
				{
				//	glFormat			= Gl.GL_ABGR_EXT;	//	NOTE: AP: Think this is correct...
					glFormat = Gl.GL_RGBA;	//	NOTE: AP: ABGR extension not supported on dev machine! SHIT!
					glInternalFormat	= Gl.GL_RGBA;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
				case PixelFormat.Format32bppPArgb		:	break;
				case PixelFormat.Format32bppRgb			:
				{
					//	glFormat			= Gl.GL_ABGR_EXT;
					glFormat = Gl.GL_RGBA;	//	NOTE: AP: ABGR extension not supported on dev machine! SHIT!
					glInternalFormat	= Gl.GL_RGBA;
					glType				= Gl.GL_UNSIGNED_BYTE;
					return format;
				}
				case PixelFormat.Format48bppRgb			:	break;
				case PixelFormat.Format4bppIndexed		:	break;
				case PixelFormat.Format64bppArgb		:	break;
				case PixelFormat.Format64bppPArgb		:	break;
				case PixelFormat.Format8bppIndexed		:	break;
				case PixelFormat.Gdi					:	break;
				case PixelFormat.Indexed				:	break;
				case PixelFormat.Max					:	break;
				case PixelFormat.PAlpha					:	break;
			}

			glInternalFormat	= Gl.GL_RGB;
			glFormat			= Gl.GL_BGR_EXT;
			glType				= Gl.GL_UNSIGNED_BYTE;

			return PixelFormat.Format24bppRgb;
		}
		 */
		#endregion
	}
}

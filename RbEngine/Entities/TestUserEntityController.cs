using System;
using RbEngine.Components;
using RbEngine.Rendering;

namespace RbEngine.Entities
{
	/// <summary>
	/// Test command set
	/// </summary>
	public enum TestCommands
	{
		[ Interaction.CommandEnumDescription( "Moves forwards" ) ]
		Forward,

		[ Interaction.CommandEnumDescription( "Moves backwards" ) ]
		Back,

		[ Interaction.CommandEnumDescription( "Moves left" ) ]
		Left,

		[ Interaction.CommandEnumDescription( "Moves right" ) ]
		Right,

		[ Interaction.CommandEnumDescription( "Fires the current weapon" ) ]
		Shoot,

		[ Interaction.CommandEnumDescription( "Jumps" ) ]
		Jump,

		[ Interaction.CommandEnumDescription( "Looks at a point" ) ]
		[ Interaction.CommandEnumInputInterpreter( typeof( TestLookAtInterpreter ) ) ]
		LookAt
	}

	/// <summary>
	/// Special command class for tracking the lookat position
	/// </summary>
	public class TestLookAtInterpreter : Interaction.CommandScenePickInterpreter
	{
		/// <summary>
		/// Creates a TestLookAtMessage
		/// </summary>
		public override Interaction.CommandMessage CreateMessage( Interaction.CommandInputBinding binding )
		{
			Maths.Ray3Intersection pickIntersection = GetIntersection( binding );
			if ( pickIntersection == null )
			{
				return null;
			}

			return new TestLookAtMessage( binding.Command, pickIntersection );
		}

	}

	/// <summary>
	/// Command message, generated by the TestLookAtInterpreter
	/// </summary>
	public class TestLookAtMessage : Interaction.CommandMessage
	{
		/// <summary>
		/// Default contructor - for serialisation purposes
		/// </summary>
		public TestLookAtMessage( )
		{
		}

		/// <summary>
		/// Setup constructor
		/// </summary>
		public TestLookAtMessage( Interaction.Command cmd, Maths.Ray3Intersection intersection ) :
				base( cmd )
		{
			//	Should be quantised, relative to controlled entity
			m_Point = intersection.IntersectionPosition;
		}

		/// <summary>
		/// Reads this message
		/// </summary>
		protected override void Read( System.IO.BinaryReader input )
		{
			base.Read( input );
			m_Point = new Maths.Point3( input.ReadSingle( ), input.ReadSingle( ), input.ReadSingle( ) );
		}

		/// <summary>
		/// Writes this message
		/// </summary>
		public override void Write( System.IO.BinaryWriter output )
		{
			base.Write( output );
			output.Write( m_Point.X );
			output.Write( m_Point.Y );
			output.Write( m_Point.Z );
		}

		/// <summary>
		/// Gets the look at point
		/// </summary>
		public Maths.Point3 Point
		{
			get
			{
				return m_Point;
			}
		}


		private Maths.Point3 m_Point;
	}

	/// <summary>
	/// Converts command messages into movement messages
	/// </summary>
	public class TestUserEntityController : Scene.ISceneObject, Components.IChildObject
	{
		#region	Command event handling

		private float	Speed
		{
			get
			{
				return 15.0f;
			}
		}

		private void OnForward( Interaction.CommandMessage message )
		{
			Entity3	entity				= ParentEntity;
			float	distanceToLookAt	= m_LookAt.Next.DistanceTo( entity.Position.Next );
			float	curSpeed			= Speed;
			if ( distanceToLookAt > curSpeed )
			{
				curSpeed = ( distanceToLookAt > 80.0f ) ? 8.0f : curSpeed;
				SendMovement( entity.Facing * curSpeed );
			}
		}

		private void OnBack( Interaction.CommandMessage message )
		{
			SendMovement( ParentEntity.Facing * -Speed );
		}

		private void OnLeft( Interaction.CommandMessage message )
		{
			SendMovement( ParentEntity.Left * Speed );
		}

		private void OnRight( Interaction.CommandMessage message )
		{
			SendMovement( ParentEntity.Right * Speed );
		}

		private void OnShoot( Interaction.CommandMessage message )
		{
		}

		private void OnJump( Interaction.CommandMessage message )
		{
			ParentEntity.HandleMessage( new JumpRequest( 0, 0, false ) );
		}

		private void OnLookAt( Interaction.CommandMessage message )
		{
			TestLookAtMessage lookAtMessage = ( TestLookAtMessage )message;

			m_LookAt.Next = lookAtMessage.Point;

			Entity3 entity	= ParentEntity;
			entity.Facing	= ( m_LookAt.Next - entity.Position.Next ).MakeNormal( );
			entity.Left		= Maths.Vector3.Cross( entity.Up, entity.Facing ).MakeNormal( );
		}

		/// <summary>
		/// Sends a movement message to the parent entity
		/// </summary>
		private void SendMovement( Maths.Vector3 vec )
		{
			Entity3 entity = ParentEntity;

			//	Turn movement into units per second (irrespective of clock update rate)
			vec *= ( float )TinyTime.ToSeconds( entity.Position.LastStepInterval );

			ParentEntity.HandleMessage( new MovementXzRequest( vec.X, vec.Z, false ) );

			entity.Facing	= ( m_LookAt.Next - entity.Position.Next ).MakeNormal( );
			entity.Left		= Maths.Vector3.Cross( entity.Up, entity.Facing ).MakeNormal( );
		}

		private Components.MessageRecipientResult ReceivedCommandMessage( Message msg )
		{
			Interaction.CommandMessage cmdMessage = ( Interaction.CommandMessage )msg;
			switch ( cmdMessage.CommandId )
			{
				case ( int )TestCommands.Forward	: OnForward( cmdMessage );	break;
				case ( int )TestCommands.Back		: OnBack( cmdMessage );		break;
				case ( int )TestCommands.Left		: OnLeft( cmdMessage );		break;
				case ( int )TestCommands.Right		: OnRight( cmdMessage );	break;
				case ( int )TestCommands.Shoot		: OnShoot( cmdMessage );	break;
				case ( int )TestCommands.Jump		: OnJump( cmdMessage );		break;
				case ( int )TestCommands.LookAt		: OnLookAt( cmdMessage );	break;
			}

			return Components.MessageRecipientResult.DeliverToNext;
		}

		#endregion

		/// <summary>
		/// Gets the entity that owns this controller
		/// </summary>
		private Entity3				ParentEntity
		{
			get
			{
				return ( Entity3 )m_Parent;
			}
		}

		#region ISceneRenderable Members

		/// <summary>
		/// Gets the list of objects to apply before rendering
		/// </summary>
		public ApplianceList	PreRenderList
		{
			get
			{
				return m_PreRenderAppliances;
			}
		}

		/// <summary>
		/// Renders this object
		/// </summary>
		public void Render( long renderTime )
		{
			Entity3			entity		= ParentEntity;
			Maths.Point3	pos			= entity.Position.Get( renderTime );
			Maths.Point3	lookAtPos	= m_LookAt.Get( renderTime );

			//	Rendering.ShapeRenderer.Inst.DrawLine( pos, pos + entity.Facing * 3.0f );
			//	Rendering.ShapeRenderer.Inst.DrawLine( pos, pos + entity.Left * 3.0f );
			//	Rendering.ShapeRenderer.Inst.DrawLine( pos, pos + entity.Up * 3.0f );
			Rendering.ShapeRenderer.Inst.DrawSphere( lookAtPos, 1.0f );
		}

		#endregion

		#region ISceneObject Members

		/// <summary>
		/// Called when this object is added to a scene
		/// </summary>
		public void AddedToScene( Scene.SceneDb db )
		{
			//	Add this object to the render manager
			db.Rendering.AddObject( this );
		}

		/// <summary>
		/// Called when this object is removed from a scene
		/// </summary>
		public void RemovedFromScene( Scene.SceneDb db )
		{
			//	Remove this object from the render manager
			db.Rendering.RemoveObject( this );
		}

		#endregion

		#region IChildObject Members

		/// <summary>
		/// Called when this object is added another
		/// </summary>
		public void AddedToParent( Object parentObject )
		{
			m_Parent = parentObject;
			( ( Components.IMessageHandler )parentObject ).AddRecipient( typeof( Interaction.CommandMessage ), new Components.MessageRecipientDelegate( ReceivedCommandMessage ), ( int )Components.MessageRecipientOrder.Default );
		}

		#endregion

		#region	Private stuff

		private Maths.Point3Interpolator	m_LookAt				= new Maths.Point3Interpolator( );
		private ApplianceList				m_PreRenderAppliances	= new ApplianceList( );
		private Object						m_Parent;

		#endregion

	}
}

using System;
using System.Xml;
using System.Collections;

namespace RbEngine.Components
{
	//	TODO: Refactor a bit (most of the RbXml... classes don't need to be publicly visible like this - they can be private inside the RbXmlLoader class
	//	also, rename the RbXmlLoader class - it's a sucky name (ObjectXmlLoader?)
	//	Finally, change the Object property of RbXmlBase, because it's confusing

	/// <summary>
	/// Base XML loader class
	/// </summary>
	public class RbXmlBase
	{
		/// <summary>
		/// Gets the object generated by the base
		/// </summary>
		public object			Object
		{
			set
			{
				m_Object = value;
				m_ObjectAsParent = m_Object as IParentObject;
			}
			get
			{
				return m_Object;
			}
		}

		/// <summary>
		/// XML element
		/// </summary>
		public XmlElement		Element
		{
			get
			{
				return m_Element;
			}
		}

		/// <summary>
		/// Bound property name
		/// </summary>
		public string			BoundPropertyName
		{
			get
			{
				return m_BoundPropertyName;
			}
		}

		/// <summary>
		/// Returns true if objects should be added to their parents in bottom up, rather than top down, fashion
		/// </summary>
		protected virtual bool	AddToParentLast
		{
			get
			{
				return true;
			}
		}

		/// <summary>
		/// Resolves the contents of this object
		/// </summary>
		public virtual void		Resolve( Object parentObject )
		{
			//	Parse the generating element
			IXmlLoader objectXmlLoader = Object as IXmlLoader;
			if ( objectXmlLoader != null )
			{
				objectXmlLoader.ParseGeneratingElement( Element );
			}

			//	Parse unhandled elements
			if ( m_Elements != null )
			{
				if ( objectXmlLoader == null )
				{
					throw new RbXmlException( Element, "Could not handle elements: Object type \"{0}\" does not support IXmlLoader", Object.GetType( ).Name );
				}
				foreach ( XmlElement curElement in m_Elements )
				{
					objectXmlLoader.ParseElement( curElement );
				}
			}

			//	Bind this object to the parent's named property
			bool addToParent = ( BoundPropertyName == string.Empty );
			if ( !addToParent )
			{
				if ( parentObject == null )
				{
					throw new RbXmlException( Element, "Can't bind root object of type \"{1}\" to property \"{2}\"",  Object.GetType( ).Name, BoundPropertyName );
				}

				System.Reflection.PropertyInfo boundProperty = parentObject.GetType( ).GetProperty( BoundPropertyName );
				if ( boundProperty == null )
				{
					throw new RbXmlException( Element, "Object of type \"{0}\" did not have a property \"{1}\" to bind object of type \"{2}\" to", parentObject.GetType( ).Name, BoundPropertyName, Object.GetType( ).Name );
				}

				//	If the object is a list, it can only have one element
				if ( Object is IList )
				{
					IList objectList = Object as IList;
					if ( objectList.Count > 1 )
					{
						throw new RbXmlException( Element, "Could not bind list to property \"{1}\"", BoundPropertyName );
					}
					else
					{
						boundProperty.SetValue( parentObject, objectList[ 0 ], null );
					}
				}
				else
				{
					boundProperty.SetValue( parentObject, Object, null );
				}
			}
			else
			{
				addToParent = ( parentObject != null );
			}

			if ( addToParent && !AddToParentLast )
			{
				AddToParent( parentObject );
				addToParent = false;
			}

			//	Resolve child objects
			if ( m_Children != null )
			{
				foreach ( RbXmlBase xmlBase in m_Children )
				{
					xmlBase.Resolve( Object );
				}
			}


			//	Add this object to the parent object
			if ( addToParent )
			{
				AddToParent( parentObject );
			}
			
			//	Parse unhandled elements
			if ( m_PostLoadElements != null )
			{
				if ( objectXmlLoader == null )
				{
					throw new RbXmlException( Element, "Could not handle elements: Object type \"{0}\" does not support IXmlLoader", Object.GetType( ).Name );
				}
				foreach ( XmlElement curElement in m_PostLoadElements )
				{
					objectXmlLoader.ParseElement( curElement );
				}
			}
		}

		private void AddToParent( object parentObject )
		{
			IParentObject parent = parentObject as IParentObject;
			if ( parent == null )
			{
				throw new RbXmlException( Element, "Could not add child object of type \"{0}\": Parent object type \"{1}\" does not support IParentObject", parentObject.GetType( ).Name, Object.GetType( ).Name );
			}

			//	HACK: If the current object is an array, then add all the array elements to the parent!
			if ( Object is IList )
			{
				foreach ( Object subObject in ( IList )Object )
				{
					parent.AddChild( subObject );
				}
			}
			else
			{
				parent.AddChild( Object );
			}
		}

		/// <summary>
		/// Adds an XMLbase object to the object stored here
		/// </summary>
		/// <param name="xmlBase"></param>
		public virtual void		Add( RbXmlBase xmlBase )
		{
			//	Add xmlBase to the child xml base list
			if ( m_Children == null )
			{
				m_Children = new ArrayList( );
			}
			m_Children.Add( xmlBase );

		}

		/// <summary>
		/// Adds a child XML element
		/// </summary>
		public virtual void		Add( XmlElement element )
		{
			RbXmlBase xmlBase = FromElement( element );
			if ( xmlBase != null )
			{
				Add( xmlBase );
			}
			else
			{
				if ( m_Elements == null )
				{
					m_Elements = new ArrayList( );
				}
				m_Elements.Add( element );
			}
		}

		/// <summary>
		/// Adds an XML element, to be parsed after the object is loaded
		/// </summary>
		public void			AddPostLoad( XmlElement element )
		{
			if ( m_PostLoadElements == null )
			{
				m_PostLoadElements = new ArrayList( );
			}
			m_PostLoadElements.Add( element );
		}

		/// <summary>
		/// Creates an RbXmlBase instance from an XML element
		/// </summary>
		public static RbXmlBase	FromElement( XmlElement element )
		{
			RbXmlBase xmlBase = null;
			switch ( element.Name )
			{
				case "object"		: xmlBase =  new RbXmlObject( element );	break;
				case "resource"		: xmlBase =  new RbXmlResource( element );	break;
			//	case "reference"	: return new RbXmlReference( element ); 
				default				: return null;
			}

			return xmlBase;
		}

		/// <summary>
		/// Loads child nodes
		/// </summary>
		protected void LoadChildNodes( )
		{
			//	Add child nodes
			foreach ( XmlNode curNode in Element.ChildNodes )
			{
				if ( curNode.NodeType == XmlNodeType.Element )
				{
					if ( curNode.Name == "postLoad" )
					{
						foreach ( XmlNode postLoadNode in curNode.ChildNodes )
						{
							if ( postLoadNode.NodeType == XmlNodeType.Element )
							{
								AddPostLoad( ( XmlElement )postLoadNode );
							}
						}
					}
					else
					{
						Add( ( XmlElement )curNode );
					}
				}
			}
		}

		protected RbXmlBase( XmlElement element )
		{
			m_Element			= element;
			m_BoundPropertyName	= element.GetAttribute( "property" );
		}

		private XmlElement		m_Element;
		private Object			m_Object;
		private IParentObject	m_ObjectAsParent;
		private string			m_BoundPropertyName;
		private ArrayList		m_Elements;
		private ArrayList		m_PostLoadElements;
		private ArrayList		m_Children;
	}

	/// <summary>
	/// XML resource object
	/// </summary>
	public class RbXmlResource : RbXmlBase
	{
		/// <summary>
		/// Generates the resource from an element
		/// </summary>
		/// <param name="element"></param>
		public RbXmlResource( XmlElement element ) :
				base( element )
		{
			//	Create the new resource
			string resourcePath = element.GetAttribute( "path" );
			if ( resourcePath == string.Empty )
			{
				throw new RbXmlException( element, "<resource> element did not have a \"path\" attribute" );
			}

			//	TODO: Need to rescue bad resource paths (requires change to resource manager)
			object loadResult = Resources.ResourceManager.Inst.Load( resourcePath );
			Object = loadResult;

			//	Set the name of the resource
			string newResourceName = element.GetAttribute( "name" );
			if ( newResourceName != string.Empty )
			{
				if ( !( Object is Components.INamedObject ) )
				{
					string resourceStr = String.Format( "\"{0}\"(\"{1}\"", resourcePath, Object.GetType( ).Name );
					throw new RbXmlException( element, "Could not name resource {0} - type does not implement the INamedObject interface", resourceStr );
				}
				( ( Components.INamedObject )Object ).Name = newResourceName;
			}

			LoadChildNodes( );
		}
	}

	/// <summary>
	/// Stores a model set, generated from an XML element
	/// </summary>
	public class RbXmlModelSet : RbXmlBase
	{
		/// <summary>
		/// Sets up and stores a model set
		/// </summary>
		public RbXmlModelSet( XmlElement element ) :
			base( element )
		{
			//	Find an existing modelset, or create a new model set
			m_ModelSetName = element.GetAttribute( "name" );

			foreach ( XmlNode curNode in element.ChildNodes )
			{
				if ( curNode.NodeType == XmlNodeType.Element )
				{
					if ( curNode.Name == "modelSet" )
					{
						Add( new RbXmlModelSet( ( XmlElement )curNode ) );
					}
					else
					{
						Add( ( XmlElement )curNode );
					}
				}
			}
		}

		/// <summary>
		/// Model sets get added to their parents, before their children get added to them
		/// </summary>
		protected override bool	AddToParentLast
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		/// Resolves the model set and all the objects stored in it
		/// </summary>
		/// <param name="parentObject">Parent object</param>
		public override void	Resolve( Object parentObject )
		{
			//	Root model set - may exist already
			ModelSet modelSet = null;
			if ( parentObject == null )
			{
				modelSet = ModelSet.FindModelSet( m_ModelSetName, false );
			}
			else
			{
				modelSet = ( ( ModelSet )parentObject ).FindChildModelSet( m_ModelSetName );
			}

			//	If the model set did not already exist, create a new one
			if ( modelSet == null )
			{
				modelSet = new ModelSet( m_ModelSetName );
				if ( parentObject == null )
				{
					parentObject = ModelSet.Main;
				}
			}

			Object = modelSet;

			base.Resolve( parentObject );
		}

		private string		m_ModelSetName;
	}

	/// <summary>
	/// Stores an object, generated from an XML element
	/// </summary>
	public class RbXmlObject : RbXmlBase
	{
		/// <summary>
		/// Uses the specified element to generate and store an object
		/// </summary>
		/// <param name="element">Generating element</param>
		public RbXmlObject( XmlElement element ) :
			base( element )
		{
			//	Create the new object
			//	TODO: Add assembly attribute?
			string newObjectTypeName = element.GetAttribute( "type" );
			Object = AppDomainUtils.CreateInstance( newObjectTypeName );

			if ( Object == null )
			{
				throw new RbXmlException( element, "Could not create instance of object \"{0}\"", newObjectTypeName );
			}

			//	Set the name of the object
			string newObjectName = element.GetAttribute( "name" );
			if ( newObjectName != string.Empty )
			{
				if ( !( Object is Components.INamedObject ) )
				{
					throw new RbXmlException( element, "Could not name object of type \"{0}\" - type does not implement the INamedObject interface", newObjectTypeName );
				}
				( ( Components.INamedObject )Object ).Name = newObjectName;
			}

			LoadChildNodes( );
		}
	}


	/// <summary>
	/// Loads an XML object definition file
	/// </summary>
	public class RbXmlLoader : Resources.ResourceLoader
	{
		/// <summary>
		/// Loads a resource from a stream
		/// </summary>
		/// <param name="input"> Input stream to load the resource from </param>
		/// <param name="inputSource"> Source of the input stream (e.g. file path) </param>
		/// <returns> Returns Engine.Main </returns>
		public override Object Load( System.IO.Stream input, string inputSource )
		{
			XmlDocument doc = new RbXmlDocument( );
			try
			{
				doc.Load( input );

				foreach ( XmlNode curNode in doc.ChildNodes )
				{
					if ( curNode.NodeType == XmlNodeType.Element )
					{
						if ( curNode.Name != "rb" )
						{
							throw new RbXmlException( curNode, "Expected root element to be named \"rb\", not \"{0}\"", curNode.Name );
						}
						else
						{
							Object result = LoadRb( ( XmlElement )curNode );
							return result;
						}
					}
				}
			}
			catch ( System.Xml.XmlException e )
			{
				string msg = String.Format( "Invalid component XML file \"{0}\"\n{0}({1},{2}): {3}", inputSource, e.LineNumber, e.LinePosition, e.Message );
				throw new System.ApplicationException( msg, e );
			}

			return null;
		}

		/// <summary>
		/// Loads the root "rb" element, which can consist of any number of "modelSet" elements, and one "object" element
		/// </summary>
		/// <param name="element">XML "rb" element</param>
		/// <returns>Returns the root object, if one was defined</returns>
		private Object LoadRb( XmlElement element )
		{
			RbXmlObject		rootObject		= null;
			RbXmlModelSet	rootModelSet	= null;

			foreach ( XmlNode node in element.ChildNodes )
			{
				if ( node.NodeType == XmlNodeType.Element )
				{
					if ( node.Name == "modelSet" )
					{
						rootModelSet = new RbXmlModelSet( ( XmlElement )node );
					}
					else if ( node.Name == "object" )
					{
						if ( rootObject != null )
						{
							throw new RbXmlException( node, "Only allowed one root object within the <rb></rb> elements" );
						}
						rootObject = new RbXmlObject( ( XmlElement )node );
					}
					else
					{
						throw new RbXmlException( node, "Did not handle \"{0}\" element: Only \"object\" and \"modelSet\" elements are allowed as direct children of <rb></rb> elements", node.Name );
					}
				}
			}

			if ( rootModelSet != null )
			{
				rootModelSet.Resolve( null );
			}

			if ( rootObject != null )
			{
				rootObject.Resolve( null );
				return rootObject.Object;
			}

			return null;
		}

		/// <summary>
		/// Loads an XML element
		/// </summary>
		/// <param name="element">XML element</param>
		/// <param name="parentObject">The parent object</param>
		/// <exception>Throws an exception if the element did not define a valid object</exception>
		private Object LoadElement( XmlElement element, Object parentObject )
		{
			Object childObject = null;
			switch ( element.Name )
			{
				case "object"	: childObject = LoadObject( element );		break;
				case "instance"	: childObject = LoadInstance( element );	break;
				case "resource"	: childObject = LoadResource( element );	break;
				case "reference": childObject = LoadReference( element );	break;
				default			:
					IXmlLoader parentXmlLoader = parentObject as IXmlLoader;
					if ( parentXmlLoader == null )
					{
						throw new RbXmlException( element, "Unable to handle element \"{0}\": Parent object type (\"{1}\") did not implement IXmlLoader", element.Name, parentObject.GetType( ).Name );
					}
					if ( !parentXmlLoader.ParseElement( element ) )
					{
						throw new RbXmlException( element, "Unable to handle element \"{0}\": Parent object type \"{1}\" did not handle element", element.Name, parentObject.GetType( ).Name );
					}
					break;
			}
			
			if ( childObject != null )
			{
				string boundPropertyName = element.GetAttribute( "property" );
				if ( boundPropertyName != string.Empty )
				{
					System.Reflection.PropertyInfo boundProperty = parentObject.GetType( ).GetProperty( boundPropertyName );
					if ( boundProperty == null )
					{
						throw new RbXmlException( element, "Object of type \"{0}\" did not have a property \"{1}\" to bind to", parentObject.GetType( ).Name, boundPropertyName );
					}
					boundProperty.SetValue( parentObject, childObject, null );
				}
				else
				{
					if ( !( parentObject is Components.IParentObject ) )
					{
						throw new RbXmlException( element, "Can't add objects to object of type \"{0}\" - did not implement the IParentObject interface", parentObject.GetType( ).Name );
					}
					( ( Components.IParentObject )parentObject ).AddChild( childObject );
				}
			}

			return childObject;
		}

		/// <summary>
		/// Loads an object from the 
		/// </summary>
		/// <param name="reader"></param>
		/// <returns></returns>
		private Object LoadObject( XmlElement element )
		{
			//	Create the new object
			//	TODO: Add assembly attribute?
			string newObjectTypeName = element.GetAttribute( "type" );
			Object obj = AppDomainUtils.CreateInstance( newObjectTypeName );

			if ( obj == null )
			{
				throw new RbXmlException( element, "Could not create instance of object \"{0}\"", newObjectTypeName );
			}

			if ( obj is IXmlLoader )
			{
				( ( IXmlLoader )obj ).ParseGeneratingElement( element );
			}

			//	Set the name of the object
			string newObjectName = element.GetAttribute( "name" );
			if ( newObjectName != string.Empty )
			{
				if ( !( obj is Components.INamedObject ) )
				{
					throw new RbXmlException( element, "Could not name object of type \"{0}\" - type does not implement the INamedObject interface", newObjectTypeName );
				}
				( ( Components.INamedObject )obj ).Name = newObjectName;
			}

			foreach ( XmlNode curNode in element.ChildNodes )
			{
				if ( curNode.NodeType == XmlNodeType.Element )
				{
					LoadElement( ( XmlElement )curNode, obj );
				}
			}

			return obj;
		}

		private Object LoadInstance( XmlElement element )
		{
			string path = element.GetAttribute( "path" );
			Object instancerObject = ModelSet.Find( path );

			if ( instancerObject == null )
			{
				throw new RbXmlException( element, "Unable to find object \"{0}\" in model set", path );
			}
			IInstanceable instancer = instancerObject as IInstanceable;
			if ( instancer == null )
			{
				throw new RbXmlException( element, "Modelset object of type \"{0}\" (path \"{1}\") cannot be used as an instancer because it does not implement IInstanceable", instancerObject.GetType( ).Name, path );
			}
			Object instance = instancer.CreateInstance( );

			foreach ( XmlNode curNode in element.ChildNodes )
			{
				if ( curNode.NodeType == XmlNodeType.Element )
				{
					LoadElement( ( XmlElement )curNode, instance );
				}
			}

			return instance;
		}

		private ModelSet LoadModelSet( XmlElement element, ModelSet curModelSet )
		{
			//	Find an existing modelset, or create a new model set
			string modelSetName = element.GetAttribute( "name" );
			ModelSet newModelSet = ModelSet.FindModelSet( modelSetName, false );

			if ( newModelSet == null )
			{
				newModelSet = new ModelSet( modelSetName );
				curModelSet.AddChild( newModelSet );
			}

			foreach ( XmlNode curNode in element.ChildNodes )
			{
				if ( curNode.NodeType == XmlNodeType.Element )
				{
					if ( curNode.Name == "modelSet" )
					{
						LoadModelSet( ( XmlElement )curNode, newModelSet );
					}
					else
					{
						LoadElement( ( XmlElement )curNode, curModelSet );
					}
				}
			}

			return newModelSet;
		}

		private Object LoadResource( XmlElement element )
		{
			//	Create the new resource
			string resourcePath = element.GetAttribute( "path" );

			Object newResource = Resources.ResourceManager.Inst.Load( resourcePath );

			//	Set the name of the resource
			string newResourceName = element.GetAttribute( "name" );
			if ( newResourceName != string.Empty )
			{
				if ( !( newResource is Components.INamedObject ) )
				{
					string resourceStr = String.Format( "\"{0}\"(\"{1}\"", resourcePath, newResource.GetType( ).Name );
					throw new RbXmlException( element, "Could not name resource {0} - type does not implement the INamedObject interface", resourceStr );
				}
				( ( Components.INamedObject )newResource ).Name = newResourceName;
			}

			foreach ( XmlNode curNode in element.ChildNodes )
			{
				if ( curNode.NodeType == XmlNodeType.Element )
				{
					LoadElement( ( XmlElement )curNode, newResource );
				}
			}

			return newResource;
		}

		private Object	LoadReference( XmlElement element )
		{
			string		name = element.GetAttribute( "name" );
			string[]	path = name.Split( '.' );

			throw new RbXmlException( element, "<reference> tag to \"{0}\": References aren't supported yet, sorry", name );
		}

		/// <summary>
		/// Returns true if this loader can load the specified stream
		/// </summary>
		/// <param name="path"> Stream path (contains extension that the loader can check)</param>
		/// <param name="input"> Input stream (file types can be identified by peeking at header bytes) </param>
		/// <returns> Returns true if the stream can </returns>
		/// <remarks>
		/// path can be null, in which case, the loader must be able to identify the resource type by checking the content in input (e.g. by peeking
		/// at the header bytes).
		/// </remarks>
		public override bool CanLoadStream( string path, System.IO.Stream input )
		{
			//	TODO: Bit of a bodge here to associate component files with the "xml" extension
			return path.EndsWith( ".components" ) || path.EndsWith( ".xml" );
		}

	}
}

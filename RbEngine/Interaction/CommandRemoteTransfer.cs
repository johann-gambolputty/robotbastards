using System;
using RbEngine.Components;
using RbEngine.Network.Runt;

namespace RbEngine.Interaction
{
	/// <summary>
	/// A Runt IRemoteUpdater. Sends command messages generated by Interaction.Command objects to a server
	/// </summary>
	/// <remarks>
	/// This picks up command messages being sent along the parent object's recipient chain. It removes them
	/// from the chain, and passes them on to a remote object.
	/// It's expected that the remote object will return the favour, and return the command message (usually using
	/// a <see cref="CommandRemoteUpdater"/>). A CommandRemoteTransfer will listen out for this returned message,
	/// and send it to the parent object again, for normal processing.
	/// </remarks>
	public class CommandRemoteTransfer : Network.Runt.IRemoteUpdater, IChildObject, Scene.ISceneObject
	{
		#region	IUnique Members

		/// <summary>
		/// Gets the ID of this updater (returns the ID of the parent object
		/// </summary>
		public ObjectId Id
		{
			get
			{
				return ( ( IUnique )m_Parent ).Id;
			}
		}

		#endregion

		#region IRemoteUpdater Members

		/// <summary>
		/// Sets the local sequence value. All messages retrived from this updater by GetUpdateMessages() will be tagged with this sequence
		/// </summary>
		public void SetLocalSequence( uint sequence )
		{
			m_LocalSequence = sequence;
		}

		/// <summary>
		/// Tells the updater what the sequence value of the most out-of-synch remote object is
		/// </summary>
		public void SetOldestRemoteSequence( uint sequence )
		{
			m_Buffer.SetOldestSequence( sequence );
		}

		/// <summary>
		/// Handles an update message sent from this updater's remote counterpart
		/// </summary>
		public void HandleUpdateMessage( Network.Runt.UpdateMessage msg )
		{
			//	Get the payload, mark this object as the sender*, and send it on to the parent object
			//
			//	* The reason for this is because this object pulls out command messages from its parent's command message recipient
			//	chain, sending them on to the server (which is where the command message came from in the first place). By marking
			//	the payload with this object as the sender, this infinite loop can be avoided.
			Components.Message baseMessage = msg.Payload;
			baseMessage.Sender = this;
			( ( Components.IMessageHandler )m_Parent ).HandleMessage( baseMessage );
		}

		/// <summary>
		/// Gets update messages to send to this updater's remote counterpart, which has a sequence value of remoteSequence
		/// </summary>
		public void GetUpdateMessages( System.Collections.ArrayList messages, uint remoteSequence )
		{
			m_Buffer.GetMessages( messages, remoteSequence );
		}

		#endregion

		#region IChildObject Members

		/// <summary>
		/// Called when this object is added to a parent object. The parent object is the command message source for this object
		/// </summary>
		public void AddedToParent( Object parentObject )
		{
			m_Parent = parentObject;

			( ( Components.IMessageHub )m_Parent ).AddRecipient( typeof( CommandMessage ), new Components.MessageRecipientDelegate( ReceivedCommandMessage ), ( int )Components.MessageRecipientOrder.First );
		}

		#endregion

		#region ISceneObject Members

		/// <summary>
		/// Called when this object is added to the scene
		/// </summary>
		public void AddedToScene( Scene.SceneDb db )
		{
			//	Add this updater to the server updater
			//	Network.Runt.ServerUpdateManager updateManager = ( Network.Runt.ServerUpdateManager )db.GetSystem( typeof( Network.Runt.ServerUpdateManager ) );
			//	if ( updateManager == null )
			//	{
			//		throw new ApplicationException( "CommandServerUpdater requires a ServerUpdateManager to present in the scene systems" );
			//	}
			Network.Runt.RemoteUpdateManager updateManager = ( Network.Runt.RemoteUpdateManager )db.GetSystem( typeof( Network.Runt.RemoteUpdateManager ) );
			if ( updateManager == null )
			{
				throw new ApplicationException( "CommandServerUpdater requires a RemoteUpdateManager to present in the scene systems" );
			}

			updateManager.AddUpdater( this );
		}

		/// <summary>
		/// Called when this object is removed from the scene
		/// </summary>
		public void RemovedFromScene( Scene.SceneDb db )
		{
		}

		#endregion

		#region	Private stuff

		private uint					m_LocalSequence;
		private Object					m_Parent;
		private MessageBufferUpdater	m_Buffer = new Network.Runt.MessageBufferUpdater( );

		/// <summary>
		/// Called when this object receives a command message
		/// </summary>
		private Components.MessageRecipientResult ReceivedCommandMessage( Components.Message msg )
		{
			//	If the sender was this object, then the message was received from the server by HandleServerUpdate(), and it must be ignored
			if ( msg.Sender == this )
			{
				return Components.MessageRecipientResult.DeliverToNext;
			}

			m_Buffer.AddMessage( new UpdateMessage( Id, m_LocalSequence, msg ), m_LocalSequence );

			return Components.MessageRecipientResult.RemoveFromChain;
		}

		#endregion
	}
}
